<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boink!</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/15.1.3/Tone.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        const BounceGame = () => {
            const canvasRef = useRef(null);
            const [gameState, setGameState] = useState('start'); // 'start', 'playing', 'gameover'
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => {
                const saved = localStorage.getItem('bounceGameHighScore');
                return saved ? parseInt(saved, 10) : 0;
            });
            const [showSettings, setShowSettings] = useState(false);
            const [gravity, setGravity] = useState(() => {
                const saved = localStorage.getItem('bounceGameGravity');
                return saved ? parseFloat(saved) : 0.3;
            });
            const [hitForce, setHitForce] = useState(() => {
                const saved = localStorage.getItem('bounceGameHitForce');
                return saved ? parseInt(saved, 10) : 30;
            });
            const [hitZone, setHitZone] = useState(() => {
                const saved = localStorage.getItem('bounceGameHitZone');
                return saved ? parseInt(saved, 10) : 90;
            });
            const [soundEnabled, setSoundEnabled] = useState(() => {
                const saved = localStorage.getItem('bounceGameSound');
                return saved ? saved === 'true' : true;
            });

            const audioContextRef = useRef(null);
            const backgroundMusicRef = useRef(null);
            const synthRef = useRef(null);
            const particlesRef = useRef([]);
            
            const ballRef = useRef({
                x: 200,
                y: 100,
                vx: 0,
                vy: 0,
                radius: 30
            });

            const settingsRef = useRef({
                draggingSlider: null,
                sliders: {
                gravity: { x: 50, y: 150, width: 300, min: 0.1, max: 0.8 },
                hitForce: { x: 50, y: 230, width: 300, min: 5, max: 40 },
                hitZone: { x: 50, y: 310, width: 300, min: 50, max: 200 }
                },
                soundToggle: { x: 150, y: 390, width: 100, height: 40 }
            });

            const isDraggingRef = useRef(false);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                canvas.width = 400;
                canvas.height = 600;

                // Initialize audio context and background music
                const initAudio = async () => {
                try {
                    await Tone.start();
                    console.log('Tone.js audio context started');
                    
                    // Always try to start music if sound is enabled and we're playing
                    if (soundEnabled && gameState === 'playing') {
                    console.log('Attempting to start background music...');
                    console.log('backgroundMusicRef.current:', backgroundMusicRef.current);
                    
                    // Ensure transport is stopped and cleared
                    if (Tone.Transport.state === 'started') {
                        Tone.Transport.stop();
                    }
                    Tone.Transport.cancel();
                    Tone.Transport.position = 0;
                    
                    // Create synth for melody - brighter anime-style sound
                    if (!synthRef.current) {
                        synthRef.current = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'triangle' },
                        envelope: {
                            attack: 0.005,
                            decay: 0.1,
                            sustain: 0.4,
                            release: 0.2
                        },
                        volume: -8
                        }).toDestination();
                    }
                    
                    // Create bass synth - punchy anime bass
                    const bass = new Tone.Synth({
                        oscillator: { type: 'sawtooth' },
                        envelope: {
                        attack: 0.01,
                        decay: 0.2,
                        sustain: 0.4,
                        release: 0.3
                        },
                        volume: -12
                    }).toDestination();
                    
                    // Japanese pentatonic melody - upbeat anime style
                    const melody = [
                        { note: 'E5', time: '0:0:0', duration: '16n' },
                        { note: 'G5', time: '0:0:1', duration: '16n' },
                        { note: 'A5', time: '0:0:2', duration: '16n' },
                        { note: 'B5', time: '0:0:3', duration: '16n' },
                        { note: 'E6', time: '0:1:0', duration: '8n' },
                        { note: 'D6', time: '0:1:2', duration: '8n' },
                        { note: 'B5', time: '0:2:0', duration: '8n' },
                        { note: 'G5', time: '0:2:2', duration: '16n' },
                        { note: 'A5', time: '0:2:3', duration: '16n' },
                        { note: 'B5', time: '0:3:0', duration: '8n' },
                        { note: 'A5', time: '0:3:2', duration: '16n' },
                        { note: 'G5', time: '0:3:3', duration: '16n' },
                        
                        { note: 'E5', time: '1:0:0', duration: '16n' },
                        { note: 'G5', time: '1:0:1', duration: '16n' },
                        { note: 'B5', time: '1:0:2', duration: '8n' },
                        { note: 'D6', time: '1:1:0', duration: '8n' },
                        { note: 'E6', time: '1:1:2', duration: '16n' },
                        { note: 'D6', time: '1:1:3', duration: '16n' },
                        { note: 'B5', time: '1:2:0', duration: '8n' },
                        { note: 'A5', time: '1:2:2', duration: '8n' },
                        { note: 'G5', time: '1:3:0', duration: '4n' }
                    ];
                    
                    // Create repeating pattern
                    const melodyPart = new Tone.Part((time, note) => {
                        synthRef.current.triggerAttackRelease(note.note, note.duration, time);
                    }, melody).start(0);
                    
                    melodyPart.loop = true;
                    melodyPart.loopEnd = '2m';
                    
                    // Energetic bass pattern - anime style
                    const bassPart = new Tone.Pattern((time, note) => {
                        bass.triggerAttackRelease(note, '8n', time);
                    }, ['E2', 'E2', 'B1', 'E2', 'D2', 'D2', 'A1', 'D2'], 'up').start(0);
                    
                    bassPart.interval = '8n';
                    
                    // Fast tempo for excitement
                    Tone.Transport.bpm.value = 160;
                    Tone.Transport.start();
                    
                    console.log('Background music started successfully!');
                    backgroundMusicRef.current = { melodyPart, bassPart, bass };
                    }
                } catch (error) {
                    console.error('Error starting audio:', error);
                }
                };

                const stopBackgroundMusic = () => {
                if (backgroundMusicRef.current) {
                    console.log('Stopping background music');
                    try {
                    Tone.Transport.stop();
                    Tone.Transport.cancel();
                    if (backgroundMusicRef.current.melodyPart) {
                        backgroundMusicRef.current.melodyPart.dispose();
                    }
                    if (backgroundMusicRef.current.bassPart) {
                        backgroundMusicRef.current.bassPart.dispose();
                    }
                    if (backgroundMusicRef.current.bass) {
                        backgroundMusicRef.current.bass.dispose();
                    }
                    } catch (e) {
                    console.log('Error stopping music:', e);
                    }
                    backgroundMusicRef.current = null;
                }
                };

                const playHitSound = () => {
                if (!soundEnabled) return;
                try {
                    const synth = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: {
                        attack: 0.005,
                        decay: 0.1,
                        sustain: 0.0,
                        release: 0.1
                    }
                    }).toDestination();
                    
                    synth.triggerAttackRelease('C6', '16n');
                    
                    setTimeout(() => synth.dispose(), 200);
                } catch (error) {
                    console.log('Error playing hit sound:', error);
                }
                };

                const createSparkles = (x, y, count) => {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                    const speed = 2 + Math.random() * 3;
                    particlesRef.current.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    size: 2 + Math.random() * 3,
                    color: `hsl(${Math.random() * 60 + 40}, 100%, 70%)`
                    });
                }
                };

                let animationId;

                const drawButton = (text, x, y, width, height) => {
                ctx.fillStyle = 'rgba(139, 92, 246, 0.9)';
                ctx.fillRect(x, y, width, height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, x + width / 2, y + height / 2);
                };

                const drawSlider = (label, value, sliderKey) => {
                const slider = settingsRef.current.sliders[sliderKey];
                const { x, y, width, min, max } = slider;
                
                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`${label}: ${value.toFixed(sliderKey === 'gravity' ? 2 : 0)}${sliderKey === 'hitZone' ? 'px' : ''}`, x, y - 10);
                
                // Track
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(x, y, width, 6);
                
                // Handle
                const handleX = x + ((value - min) / (max - min)) * width;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(handleX, y + 3, 12, 0, Math.PI * 2);
                ctx.fill();
                };

                const isPointInRect = (px, py, x, y, width, height) => {
                return px >= x && px <= x + width && py >= y && py <= y + height;
                };

                const handleCanvasClick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
                const clickY = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
                const canvasX = clickX * scaleX;
                const canvasY = clickY * scaleY;

                // Settings icon click (top-right)
                if (gameState !== 'playing' && isPointInRect(canvasX, canvasY, 350, 10, 40, 40)) {
                    setShowSettings(!showSettings);
                    return;
                }

                // Sound toggle button
                if (showSettings && gameState !== 'playing') {
                    const soundToggle = settingsRef.current.soundToggle;
                    if (isPointInRect(canvasX, canvasY, soundToggle.x, soundToggle.y, soundToggle.width, soundToggle.height)) {
                    const newValue = !soundEnabled;
                    setSoundEnabled(newValue);
                    localStorage.setItem('bounceGameSound', newValue.toString());
                    if (!newValue) {
                        stopBackgroundMusic();
                    }
                    return;
                    }
                }

                // Settings slider interaction
                if (showSettings && gameState !== 'playing') {
                    Object.entries(settingsRef.current.sliders).forEach(([key, slider]) => {
                    if (isPointInRect(canvasX, canvasY, slider.x - 12, slider.y - 12, slider.width + 24, 30)) {
                        isDraggingRef.current = key;
                        const ratio = Math.max(0, Math.min(1, (canvasX - slider.x) / slider.width));
                        const newValue = slider.min + ratio * (slider.max - slider.min);
                        if (key === 'gravity') {
                        setGravity(newValue);
                        localStorage.setItem('bounceGameGravity', newValue.toString());
                        } else if (key === 'hitForce') {
                        const roundedValue = Math.round(newValue);
                        setHitForce(roundedValue);
                        localStorage.setItem('bounceGameHitForce', roundedValue.toString());
                        } else if (key === 'hitZone') {
                        const roundedValue = Math.round(newValue);
                        setHitZone(roundedValue);
                        localStorage.setItem('bounceGameHitZone', roundedValue.toString());
                        }
                    }
                    });
                    return;
                }

                // Start screen - don't allow if settings are open
                if (gameState === 'start' && !showSettings) {
                    // Pre-warm Tone.js on start screen interaction
                    if (soundEnabled) {
                    Tone.start().then(() => {
                        console.log('Audio context pre-warmed');
                    });
                    }
                    
                    setGameState('playing');
                    ballRef.current = { x: 200, y: 100, vx: 0, vy: 0, radius: 30 };
                    setScore(0);
                    particlesRef.current = [];
                    return;
                }

                // Game over screen - don't allow if settings are open
                if (gameState === 'gameover' && !showSettings) {
                    setGameState('start');
                    stopBackgroundMusic();
                    return;
                }

                // Playing - ball interaction (ONLY if we're actually playing)
                if (gameState === 'playing' && !showSettings) {
                    const ball = ballRef.current;
                    
                    // Don't allow hits if ball is already below screen
                    if (ball.y > canvas.height + ball.radius) {
                    return;
                    }
                    
                    const dx = canvasX - ball.x;
                    const dy = canvasY - ball.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < hitZone && dist > 0) {
                    const forceX = -(dx / dist) * hitForce;
                    const forceY = -(dy / dist) * hitForce;
                    ball.vx += forceX;
                    ball.vy += forceY;
                    setScore(s => s + 1);
                    createSparkles(canvasX, canvasY, 8);
                    playHitSound();
                    }
                }
                };

                const handleMouseMove = (e) => {
                if (!showSettings || gameState === 'playing' || !isDraggingRef.current) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const clickX = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
                const canvasX = clickX * scaleX;

                const key = isDraggingRef.current;
                const slider = settingsRef.current.sliders[key];
                const ratio = Math.max(0, Math.min(1, (canvasX - slider.x) / slider.width));
                const newValue = slider.min + ratio * (slider.max - slider.min);
                
                if (key === 'gravity') {
                    setGravity(newValue);
                    localStorage.setItem('bounceGameGravity', newValue.toString());
                } else if (key === 'hitForce') {
                    const roundedValue = Math.round(newValue);
                    setHitForce(roundedValue);
                    localStorage.setItem('bounceGameHitForce', roundedValue.toString());
                } else if (key === 'hitZone') {
                    const roundedValue = Math.round(newValue);
                    setHitZone(roundedValue);
                    localStorage.setItem('bounceGameHitZone', roundedValue.toString());
                }
                };

                const handleMouseUp = () => {
                isDraggingRef.current = false;
                };

                canvas.addEventListener('mousedown', handleCanvasClick);
                canvas.addEventListener('touchstart', handleCanvasClick);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('touchmove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('touchend', handleMouseUp);
                document.addEventListener('mouseup', handleMouseUp);
                document.addEventListener('touchend', handleMouseUp);

                const gameLoop = () => {
                const ball = ballRef.current;

                // Start music when entering playing state
                if (gameState === 'playing' && soundEnabled && !backgroundMusicRef.current) {
                    // Ensure Transport is ready before starting music
                    if (Tone.Transport.state !== 'started') {
                    initAudio();
                    }
                }

                // Physics update
                if (gameState === 'playing') {
                    ball.vy += gravity;
                    ball.x += ball.vx;
                    ball.y += ball.vy;
                    ball.vx *= 0.99;
                    ball.vy *= 0.995;

                    // Bounce off walls
                    if (ball.x < ball.radius) {
                    ball.x = ball.radius;
                    ball.vx = Math.abs(ball.vx) * 0.7;
                    createSparkles(ball.x, ball.y, 5);
                    }
                    if (ball.x > canvas.width - ball.radius) {
                    ball.x = canvas.width - ball.radius;
                    ball.vx = -Math.abs(ball.vx) * 0.7;
                    createSparkles(ball.x, ball.y, 5);
                    }

                    // Game over if falls off bottom
                    if (ball.y > canvas.height + ball.radius) {
                    setGameState('gameover');
                    stopBackgroundMusic();
                    if (score > highScore) {
                        setHighScore(score);
                        localStorage.setItem('bounceGameHighScore', score.toString());
                    }
                    }
                }

                // Update particles
                particlesRef.current = particlesRef.current.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.15; // Gravity on particles
                    p.life -= 0.02;
                    return p.life > 0;
                });

                // Draw
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Animated background stars (always visible)
                const time = Date.now() * 0.001;
                for (let i = 0; i < 30; i++) {
                    const x = (i * 73) % canvas.width;
                    const y = ((i * 127 + time * 20) % canvas.height);
                    const size = 1 + (i % 3);
                    const alpha = 0.3 + Math.sin(time + i) * 0.3;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Settings icon (gear)
                if (gameState !== 'playing') {
                    ctx.fillStyle = showSettings ? '#8b5cf6' : 'rgba(255, 255, 255, 0.5)';
                    ctx.font = 'bold 30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('âš™ï¸', 370, 35);
                }

                // Settings panel
                if (showSettings && gameState !== 'playing') {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(30, 80, 340, 360);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('SETTINGS', 200, 120);

                    drawSlider('Gravity', gravity, 'gravity');
                    drawSlider('Hit Force', hitForce, 'hitForce');
                    drawSlider('Hit Zone', hitZone, 'hitZone');

                    // Sound toggle button
                    const soundToggle = settingsRef.current.soundToggle;
                    ctx.fillStyle = soundEnabled ? '#10b981' : '#ef4444';
                    ctx.fillRect(soundToggle.x, soundToggle.y, soundToggle.width, soundToggle.height);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(soundEnabled ? 'ðŸ”Š ON' : 'ðŸ”‡ OFF', soundToggle.x + soundToggle.width / 2, soundToggle.y + soundToggle.height / 2);
                }

                // Start screen
                if (gameState === 'start' && !showSettings) {
                    // Gradient background overlay
                    const gradient = ctx.createRadialGradient(200, 300, 50, 200, 300, 300);
                    gradient.addColorStop(0, 'rgba(138, 43, 226, 0.3)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Animated title with glow
                    const titleY = 200 + Math.sin(time * 2) * 8;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff00ff';
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 72px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('BOINK!', 200, titleY);
                    ctx.shadowBlur = 0;
                    
                    // Anime-style speed lines
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                    const angle = (time + i) * 0.5;
                    const x1 = 200 + Math.cos(angle) * 60;
                    const y1 = 210 + Math.sin(angle) * 60;
                    const x2 = 200 + Math.cos(angle) * 120;
                    const y2 = 210 + Math.sin(angle) * 120;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    }
                    
                    // Floating action text with pulse
                    const pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;
                    ctx.fillStyle = `rgba(255, 255, 255, ${pulseAlpha})`;
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('TAP TO START', 200, 400);
                    
                    // Decorative corner elements
                    ctx.fillStyle = 'rgba(255, 100, 255, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(50, 0);
                    ctx.lineTo(0, 50);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(400, 0);
                    ctx.lineTo(350, 0);
                    ctx.lineTo(400, 50);
                    ctx.fill();
                    
                    if (highScore > 0) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 18px Arial';
                    ctx.fillText(`â˜… BEST: ${highScore} â˜…`, 200, 480);
                    }
                }

                // Playing screen
                if (gameState === 'playing') {
                    // Draw particles/sparkles
                    particlesRef.current.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    });
                    ctx.globalAlpha = 1;

                    // Score
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`Score: ${score}`, 15, 35);
                    
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillText(`Best: ${highScore}`, 15, 60);

                    // Ball
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Velocity indicator
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(ball.x, ball.y);
                    ctx.lineTo(ball.x + ball.vx * 3, ball.y + ball.vy * 3);
                    ctx.stroke();

                    // Hit zone
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, hitZone, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Game over screen
                if (gameState === 'gameover' && !showSettings) {
                    // Dark overlay with gradient
                    const gradient = ctx.createRadialGradient(200, 300, 50, 200, 300, 400);
                    gradient.addColorStop(0, 'rgba(139, 0, 0, 0.5)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Dramatic title with shadow
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff0000';
                    ctx.fillStyle = '#ff4444';
                    ctx.font = 'bold 56px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME', 200, 180);
                    ctx.fillText('OVER', 200, 240);
                    ctx.shadowBlur = 0;
                    
                    // Score box with border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(100, 270, 200, 70);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 36px Arial';
                    ctx.fillText(`${score}`, 200, 315);
                    
                    if (score === highScore && score > 0) {
                    // New high score celebration
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffd700';
                    ctx.font = 'bold 28px Arial';
                    ctx.fillStyle = '#ffd700';
                    const starY = 360 + Math.sin(time * 4) * 3;
                    ctx.fillText('â˜… NEW RECORD! â˜…', 200, starY);
                    ctx.shadowBlur = 0;
                    
                    // Celebration sparkles
                    for (let i = 0; i < 5; i++) {
                        const angle = time * 2 + (i * Math.PI * 2) / 5;
                        const dist = 80 + Math.sin(time * 3 + i) * 10;
                        const x = 200 + Math.cos(angle) * dist;
                        const y = 360 + Math.sin(angle) * dist;
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    } else if (highScore > 0) {
                    ctx.font = '22px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillText(`Best: ${highScore}`, 200, 370);
                    }
                    
                    // Pulsing continue text
                    const continueAlpha = 0.6 + Math.sin(time * 3) * 0.3;
                    ctx.font = 'bold 22px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${continueAlpha})`;
                    ctx.fillText('TAP TO CONTINUE', 200, 480);
                    
                    // Decorative lines
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(50, 420);
                    ctx.lineTo(350, 420);
                    ctx.stroke();
                }

                animationId = requestAnimationFrame(gameLoop);
                };

                gameLoop();

                return () => {
                cancelAnimationFrame(animationId);
                stopBackgroundMusic();
                canvas.removeEventListener('mousedown', handleCanvasClick);
                canvas.removeEventListener('touchstart', handleCanvasClick);
                canvas.removeEventListener('mousemove', handleMouseMove);
                canvas.removeEventListener('touchmove', handleMouseMove);
                canvas.removeEventListener('mouseup', handleMouseUp);
                canvas.removeEventListener('touchend', handleMouseUp);
                document.removeEventListener('mouseup', handleMouseUp);
                document.removeEventListener('touchend', handleMouseUp);
                };
            }, [gameState, showSettings, gravity, hitForce, hitZone, soundEnabled, score, highScore]);

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-purple-900 to-indigo-900 p-4">
                <div className="bg-white rounded-lg shadow-2xl p-6">
                    <canvas
                    ref={canvasRef}
                    className="border-4 border-purple-600 rounded-lg"
                    style={{ touchAction: 'none', width: '100%', maxWidth: '400px', height: 'auto' }}
                    />
                </div>
                </div>
            );
        };

        ReactDOM.render(<BounceGame />, document.getElementById('root'));
    </script>
</body>
</html>